#include <stdio.h>

int main()
{
    int m, n, k, p, i, d;
    printf("Input m,n\n");
    scanf("%d%d", &m, &n);
    if (m < n)
    {
        m = m ^ n;
        n = m ^ n;
        m = m ^ n;
        /*
         * 第一行：将 m^n 存入 m；
         * 第二行：相当于(m^n)^n=m，存入 n；
         * 第三行：相当于(m^n)^m=n^m^m=n，存入 m。
         */
    }
    k = 0;
    while (!(m & 1) && !(n & 1))
        /*判断奇偶，可以看二进制的最后一位是否为1，通过 &1 实现*/
    {
        /* x/=2 可写为 x=x>>1*/
        m >>= 1;
        n >>= 1;
        k++;
    }
    p = 1 << k;
    /* p=pow(2,k) 可写为 p=1<<k */

    while (n != 0)
    {
        d = m - n;
        if (d > n)
            m = d;
        else
        {
            m = n, n = d;
        }
    }
    d = m;
    d *= p;
    printf("greatest common divisor: %d", d);
    return 0;
}

/* 算法分析：
 * 1.将用户的输入数据进行格式化，使得较大的数据总是位于第一个，较小的数据总是位于第二个；
 * 2.进行一步优化，将用户输入的数据同时用2约简，使至少一个数为奇数，并记录公因子2的个数；
 * 3.执行更相减损术，反复选择 m,n,m-n 三个数中较小的两个作为新的 m,n 进入下一次迭代，
 *   直到得到的两个数最终相等；
 * 4.将原来约去的2乘入结果并输出。
 *
 * 问题分析：
 * 1.程序的在做更相减损时，条件是 m-n!=n ，这一条件是错误的，考虑到：
 *      gcd(2,2)=2，但程序在此处错误地陷入了死循环。
 *   m-n!=n 的来源是更相减损术的最后一步，当两个不同的数经过操作最终得到的差等于上一步的较小数时（例如：2-1=1），
 *   下一步理应是 1-1=0。程序作者理所当然地认为可以省去最后一步，本意是优化性能，却导致了更多的麻烦。
 * 2.程序根本没有考虑 m 与 n 中至少有一个为0地情况。当输入这样的数据时，出于与问题分析（1）相似的原因，
 *   程序亦会进入死循环。而根据数学定义，gcd(a,0)=a；
 * 3.事实上，用2约简这一步也写得不完善。如gcd(0,0)=0，在判断奇偶时就陷入死循环，无论从取模的角度还是移位的角度来看，
 *   0均被认为是偶数。
 */

